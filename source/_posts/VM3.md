---
title: 虚拟内存——动态内存分配
categories:
  - 笔记
tags:
  - 默认标签
toc: true
comments: true
description: ''
plugins:
  - mathjax
date: 2025-12-07 00:12:35
author: 土土
updated:
---

动态内存分配器维护虚拟内存的堆（heap）
<!-- more -->

分配器都显式地分配块。

- 显式分配器 malloc + free
- 隐式分配器 垃圾收集器

## 显式分配器

### 常用函数

```cpp
#include<stdlib.h>
void *malloc(size_t size);
```
若成功返回已分配块的指针，否则为NULL，并设置 errno。
> 32 位模式中 8 对齐；64 位模式中 16 对齐。

malloc 不初始化返回的内存，calloc 可初始化为零，改变已分配块的大小用 realloc。

```cpp
#include <unistd.h>
void *sbrk(intptr_t incr);
/* 返回：若成功则为旧的 brk 指针，若出错则为 -1。*/
```

sbrk 函数通过将内核的 brk 指针增加 incr 来收缩和扩展堆。

```cpp
#include<stdlib.h>
void free(void *ptr);
```
ptr 必须指向已分配的块，否则行为未定义。

### 目标与要求
#### 要求
- 处理任意请求序列。 分配器不能假设分配和释放请求的顺序。
- 立即响应。
- 只使用堆。
- 对齐块。
- 不修改已分配的块。
#### 目标
- 最大化吞吐率：每个单位时间内完成的请求数最大化。
- 最大化内存利用率。

有很多方式来描述一个分配器使用堆的效率如何。在我们的经验中，最有用的标准是
**峰值利用率（peak utilization）**。给定 $n$ 个分配和释放请求的某种顺序：

$$R_0, R_1, \cdots, R_k, \cdots, R_{n-1}$$

如果一个应用程序请求一个 $p$ 字节的块，那么得到的已分配块的**有效载荷（payload）** 是 $p$ 字节。  
在请求 $R_k$ 完成之后，**聚集有效载荷（aggregate payload）** 记为 $P_k$，为当前已分配的块的有效载荷之和；  
而 $H_k$ 表示堆的当前的（单调非递减的）大小，或指前 $k$ 个请求的最高峰。

那么，前 $k+1$ 个请求的**峰值利用率** 记为 $U_k$，可通过下式得到：

$$U_k = \frac{\max_{i \le k} P_i}{H_k}$$

---

分配器的目标是在整个序列中使峰值利用率 $U_{n-1}$ 最大化。  
正如我们将要看到的，在最大化吞吐率和最大化利用率之间是互相牵制的。  
特别是，以堆利用率为代价，很容易编写出吞吐率最大的分配器。  
分配器设计中一个有趣的挑战就是在两个目标之间找到一个适当的平衡。

### 问题
#### 碎片
造成堆利用率低的主要原因是碎片（fragmentation）。
- 内部碎片 已分配块比有效载荷大。任意时刻内部碎片的数量只取决于以前请求的模式和分配器的实现方式。
- 外部碎片 空闲内存合起来足够满足分配请求，但是分散在多个空闲块中的。不仅取决于以前请求的模式和分配器的实现方式，还取决于*将来*请求的模式。
> 外部碎片难以量化和预测，通常采用启发式策略来维持少量的大空闲块而非大量的小空闲块。

#### 其他问题
- 如何记录空闲块？
- 如何选择合适的空闲块来分配？
  - **放置策略**：首次适配；下一次适配；最佳适配。
  - 获取额外堆内存。
- 放置后如何处理这个空闲块的剩余部分？
  - **分割**。
- 如何处理刚释放的块？
  - 合并空闲块。（解决 **假碎片** 问题）立即合并 or 推迟合并。
    - 带边界标记的合并：脚部（头部的副本）。优化：只有空闲块需要脚部，在 header 里放 prev_alloc 位。

### 隐式空闲链表

- 块 = 头部 + 有效载荷 + 填充。
- 头部 = 块大小 + 分配位（最低一位）。
> 结束块：设置了分配位但大小为 0 的头部。

优点是简单，缺点是任何操作都需要对空闲链表进行搜索，搜索所需时间与堆中已分配块和空闲块的总数呈线性关系。

### 显式空闲链表
双向链表。
- 分配块 = 头部 + 有效载荷 + 填充 + 脚部
- 空闲块 = 头部 + (pred + succ + 剩余)有效载荷 + 填充 + 脚部

维护链表的方式
- 后进先出（LIFO）： 常数时间释放，若使用边界标记合并也可以在常数时间释放。
- 按照地支顺序。首次适配的内存利用率更高。

缺点是空闲块需要够大，最大块大小更大，内部碎片风险高。

### 分离空闲链表
**分离存储**：维护多个空闲链表，每个链表中的块大小大致相等。

将所有可能的块大小分成等价类，即**大小类**。

#### 简单分离存储
- 每个大小类的空闲链表的块大小相等，即这个大小类中最大元素的大小。
- 分配：首次适配的整块空闲块 or 空闲链表为空时请求固定大小的额外内存片分成相等的块组成新链表。
- 优点：分离与释放都为常数时间，不分割不合并，内存开销小，不需头部脚部。最小块大小是一个字。
- 缺点：内外碎片多。
#### 分离适配
- 分配：确定大小类，首次适配，可选地分割和合并。请求后分割合并。

> 其首次适配的内存利用率近似于对整个堆的最佳适配。

> **伙伴系统**
> 分离适配特例。每个大小类是 2 的幂。与伙伴地址只有一位不同，快速搜索与合并；内部碎片风险高。

## 垃圾收集（隐式分配器）

将内存视为一张有向可达图（reachability graph），节点分为根节点和堆节点两组。每个堆节点对应堆中的一个已分配块。根节点为不在堆中但包含了指向堆中的指针的变量。

若 malloc 找不到合适空闲块，将调用垃圾收集器。仍无则请求。调用包含标记 + 清除两阶段。

- **可达**：存在一条从任意根节点到达该点的有向路径。
- **保守的垃圾收集器**：可达的标记均正确，但不可达节点可能错误地被标记为可达。
