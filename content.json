{"meta":{"title":"Happy Door","subtitle":"","description":"","author":"John Doe","url":"https://happy-door.github.io","root":"/InDoor/"},"pages":[{"title":"","date":"2025-12-01T08:59:36.841Z","updated":"2025-12-01T08:59:36.841Z","comments":true,"path":"css/custom.css","permalink":"https://happy-door.github.io/css/custom.css","excerpt":"","text":""}],"posts":[{"title":"git操作手册-第2版","slug":"git操作手册-第2版","date":"2025-12-06T13:27:36.000Z","updated":"2025-12-06T14:19:53.026Z","comments":true,"path":"2025/12/06/git操作手册-第2版/","permalink":"https://happy-door.github.io/2025/12/06/git%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C-%E7%AC%AC2%E7%89%88/","excerpt":"继第一版 Git功法入门 后，在增加了分支控制并简化操作流程的基础上，逍遥门整合出了第二版 git 操作手册！","text":"继第一版 Git功法入门 后，在增加了分支控制并简化操作流程的基础上，逍遥门整合出了第二版 git 操作手册！ Git 操作手册 这是为 不熟悉 Git 的成员 准备的教程不会 Git 也能照着做完一次完整协作！ 熟悉 git 或者想直接操作请跳转 第一次修改前的 3 步 或 开始修改。 什么是 Git？Git 是一个 版本控制工具，可以： 记录每次修改 回退到任意历史版本 多人同时开发而互不干扰 通过 Pull Request 审核才能进入主仓库（我们已启用！） 安装与环境准备① 安装 Githttps://git-scm.com/download/win一路 Next → Next → 完成即可 ② 初次使用需要配置身份（否则无法提交）12git config --global user.name &quot;你的名字&quot;git config --global user.email &quot;你的邮箱&quot; 你的名字与邮箱将会出现在仓库贡献记录中 ③ Windows 建议使用 Git Bash右键目录 → Git Bash Here或者： 1cd 你的项目目录 Happy Door 分支协作规范 主分支 master 已启用保护 → 不允许直接 push所有修改必须通过 分支 → PR → 审核 → 合并 工作流如下： 1克隆仓库 → 创建个人分支 → 修改内容 → commit → push → Pull Request → 审核通过 → 合并 第一次修改前的 3 步1）克隆仓库到本地12git clone https://github.com/Happy-Door/InDoor.gitcd InDoor 2）每次开发前先同步最新代码1git pull origin main 以防代码冲突 3）创建你自己的分支（非常重要!!!）1git checkout -b your-name-task 示例： 123feature/alkaid-add-pdffix/vci-path-errordoc/git-guide-update 不需要每次更改都新建分支，但建议针对不同功能 &#x2F; 任务创建独立分支。 开始修改修改你想改的文件后执行： ① 查看更改1git status ② 把文件加入提交列表123git add 文件名// 或所有更改一次性添加git add . ③ 提交（commit）并附上说明文字1git commit -m &quot;feat: 新增VCI笔记&quot; Commit 信息规范推荐： 类型 示例 feat 新功能 fix 修bug docs 文档&#x2F;指南更新 style UI样式调整 推到远程仓库（push）1git push origin 你的分支名 示例： 1git push origin feature/alkaid-add-pdf 成功后 GitHub 会提示你： Create Pull Request 这一步意味着你准备将修改提交给门派审核！ Pull Request（PR）审核流程你通过本地 git 创建了 PR（如上一步所说），还需要使用 GitHub 的网页界面创建 PR 步骤： 打开 GitHub → 你的分支 → New Pull Request 选择 目标分支为 master 填写说明内容 → 点击 Create Pull Request 等待队友 Review 审核通过后 才能被合并 你不需要合并自己的 PRPR 应由其他成员审核并 Merge 你也可以去 Review 别人的改动 Hexo 特有流程（写博客时必做）Git 提交和 PR 合并 ≠ 网站自动更新你需要在本地生成并部署： 1234hexo clean // 若出现未更新情况可以清缓存hexo g // generate 生成静态文件hexo s // 可选，本地预览网站效果hexo d // deploy 上传页面 🎉 恭喜你！你已经掌握 git 操作的完整流程！感谢各位的捧场，今天的早课结束啦ᕕ ( ᐛ ) ᕗ","categories":[{"name":"新弟子进！","slug":"新弟子进！","permalink":"https://happy-door.github.io/categories/%E6%96%B0%E5%BC%9F%E5%AD%90%E8%BF%9B%EF%BC%81/"}],"tags":[{"name":"默认标签","slug":"默认标签","permalink":"https://happy-door.github.io/tags/%E9%BB%98%E8%AE%A4%E6%A0%87%E7%AD%BE/"}],"author":"土土"},{"title":"VCI","slug":"VCI","date":"2025-12-06T07:52:02.000Z","updated":"2025-12-06T08:05:31.322Z","comments":true,"path":"2025/12/06/VCI/","permalink":"https://happy-door.github.io/2025/12/06/VCI/","excerpt":"本篇是部分 vci 笔记的存档。","text":"本篇是部分 vci 笔记的存档。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://happy-door.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"默认标签","slug":"默认标签","permalink":"https://happy-door.github.io/tags/%E9%BB%98%E8%AE%A4%E6%A0%87%E7%AD%BE/"}],"author":"土土"},{"title":"虚拟内存——Linux 进程虚拟内存布局概述","slug":"VM2","date":"2025-12-06T06:57:44.000Z","updated":"2025-12-06T07:16:35.591Z","comments":true,"path":"2025/12/06/VM2/","permalink":"https://happy-door.github.io/2025/12/06/VM2/","excerpt":"本篇笔记记录 Linux 进程的虚拟内存体系结构，详细阐述了内核虚拟内存和进程虚拟内存的区域划分、数据结构以及它们在内存管理中的作用。","text":"本篇笔记记录 Linux 进程的虚拟内存体系结构，详细阐述了内核虚拟内存和进程虚拟内存的区域划分、数据结构以及它们在内存管理中的作用。 Linux 进程虚拟内存布局概述Linux 系统为每个进程都创建了一个独立的虚拟内存空间。这个虚拟地址空间通常是 $0$ 到 $2^{64}-1$ (对于 64 位系统) 或 $0$ 到 $2^{32}-1$ (对于 32 位系统)。分为两个部分 内核虚拟内存 (Kernel Virtual Memory)：位于虚拟地址空间的高位，供操作系统内核使用。 进程虚拟内存 (Process Virtual Memory)：通常位于虚拟地址空间的低位，包含用户程序运行所需的数据和代码。 内核虚拟内存区域这部分位于虚拟地址空间的高位，供内核使用，并且其内容对所有进程是“一样”或“相关”的。 1. 对每个进程都不同（私有部分） 与进程相关的数据结构： 页表：记录了当前进程虚拟地址到物理地址的映射关系，每个进程都有自己独立的页表。 task 结构：进程描述符，包含了进程 ID (PID)、状态、打开的文件等关键信息。 mm 结构：内存管理结构，描述了进程的整个虚拟地址空间布局（如各内存段的起始&#x2F;结束地址）。 内核栈 (Kernel Stack)：进程从用户态切换到内核态（如进行系统调用）时使用的栈，与用户栈是分开的。 任务结构 task_struct 中的一个条目 mm 指向 mm_struct（描述虚拟内存的当前状态），其中的 pgd 指向第一级页表的基址， mmap 指向链表 vm_area_structs。每个 vm_area_structs 描述当前虚拟地址空间的一个区域&#x2F;段。 vm_end, vm_start: 指向这个区域的起始与终点。 vm_prot: 所有页的读写权限。 vm_flags: 是否共享。 vm_next: 链表中下一个区域。 缺页异常处理中，未分配 -&gt; 段错误；权限错误 -&gt; 保护异常；未缓存 -&gt; 按需页面调度。 2. 对每个进程都一样（共享部分）这部分包含内核代码和数据，所有进程的虚拟地址都映射到相同的物理内存地址，实现了对内核资源的共享访问。 物理内存：用于映射到实际的物理内存页。 内核代码和数据：包括内核的可执行代码和全局数据结构。 进程虚拟内存区域这部分是每个进程独有的，包含了用户程序执行的关键组成部分。地址通常从低位开始向上增长。 区域名称 地址 作用及特点 用户栈 (User Stack) 地址较高，由 %rsp 指针控制 存放局部变量、函数参数、返回地址等。从高地址向低地址增长。 共享库的内存映射区域 堆上方 存放通过 mmap 系统调用映射的文件或共享库（如 .so 文件）。 运行时堆 (Heap) 紧邻未初始化数据段上方，由 brk 指针控制 存放程序运行时动态分配的内存（如使用 malloc 或 new）。从低地址向高地址增长。 未初始化数据段 (.bss) 紧邻已初始化数据段上方 存放程序中未初始化的全局变量和静态变量。在程序加载时，操作系统将其初始化为 0。 已初始化数据段 (.data) 紧邻代码段上方 存放程序中已初始化的全局变量和静态变量。 代码段 (.text) $0$ (或靠近 $0$ 的低地址) 存放可执行的机器指令。通常是只读的，以防止程序意外修改自身代码。 $0\\text{x}4000000$: 常见的 64 位 Linux ELF 可执行文件的基地址，代码段通常从这里开始。 Executable and Linkable Format, 是 Linux&#x2F;Unix 系统中使用的可执行文件格式标准 brk: 堆的边界指针。malloc 分配堆内存时会移动 brk。 %rsp: 栈指针寄存器。指向当前栈帧的顶部，栈向低地址增长。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://happy-door.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"默认标签","slug":"默认标签","permalink":"https://happy-door.github.io/tags/%E9%BB%98%E8%AE%A4%E6%A0%87%E7%AD%BE/"}],"author":"土土"},{"title":"虚拟内存——与物理内存建立映射：页","slug":"VM1","date":"2025-12-05T10:18:55.000Z","updated":"2025-12-05T10:33:14.722Z","comments":true,"path":"2025/12/05/VM1/","permalink":"https://happy-door.github.io/2025/12/05/VM1/","excerpt":"为了更好地共享同一块物理内存的数据 &amp; 简化编程模型，虚拟内存（Virtual Memory） 应运而生。虚拟内存为每个进程提供独立、连续、逻辑统一的地址空间。实际访问发生在物理内存 + 磁盘之间，由操作系统自动管理。本篇笔记记录虚拟内存的体系结构、地址翻译过程与优化机制。","text":"为了更好地共享同一块物理内存的数据 &amp; 简化编程模型，虚拟内存（Virtual Memory） 应运而生。虚拟内存为每个进程提供独立、连续、逻辑统一的地址空间。实际访问发生在物理内存 + 磁盘之间，由操作系统自动管理。本篇笔记记录虚拟内存的体系结构、地址翻译过程与优化机制。 与物理内存建立映射：页概念上，内存是一块连续字节数组，为了方便访问和存储，把地址空间进行层级划分： 把虚拟内存划分为若干大小为 P 字节的块，称为虚拟页（VP） 物理页（PP）或页帧，同理。 实际上的访问操作仍在物理内存上进行，所以需要对虚拟内存和物理内存建立映射，这个过程称为 地址翻译 。 虚拟页的生命周期在任意时刻，一个进程的虚拟地址空间中的所有虚拟页（VP）可以被划分为三个不相交的子集。 未分配 &#x3D; VM系统还未分配（或创建）的页。未分配的块没有数据与之关联，因此不占用任何磁盘空间。 分配 &#x3D; 虚拟地址与磁盘上的物理地址建立映射 未缓存 → 缺页（page fault），选择牺牲页（按需页面调度，本篇笔记称为按需加载）。数据存储在磁盘上的 交换空间（Swap Space） 中。 缓存 &#x3D; 磁盘上的数据（物理页）加载到主存。 虚拟内存的高效性 按需分配：程序启动时未分配。第一次访问一个虚拟地址时才分配。 按需加载：程序启动时不加载代码页，只在第一次访问时（读&#x2F;写）才通过 page fault 加载。 虚拟内存到磁盘的访问是昂贵的，因此 DRAM 全相联 → 操作系统可以自由选择把某个虚拟页扔到任何物理页框里 （组相联只能同组，更严苛是一一映射）（因为可以自由选择物理页框，OS 就能使用最优的页面替换算法，把最“冷”的虚拟页换出去，让最“热”的工作集留在 DRAM 中，从而避免大量昂贵的磁盘访问）。由于局部性原理，昂贵的磁盘访问 + 按需加载最终是高效的。 地址翻译虚拟地址在传送到主存前经过 MMU（memory manage unit） 翻译成物理地址。 页表 &#x3D; PTE（page table entry，页表条目）的数组 PTE &#x3D; valid bits + 物理地址（主存 or 磁盘）&#x2F;下一级页表PTE位置 虚拟地址 &#x3D; VPN + VPO，其中 VPN 是页表中 PTE 的位置。 VPN &#x3D; TLBT + TLBI VPN &#x3D; VPN1 + VPN2 + ··· 物理地址 &#x3D; PPN + VPO PPN &#x3D; CT PPO &#x3D; CI + CO PTBR（page table base register）指向内存中的页表，本身位于cpu中。 流程： CPU 产生虚拟地址 VA，MMU 先访问TLB，不命中则进行页表遍历。使用 PTBR 指向的基地址，通过 VPN 访问 L1 中缓存的页表条目，一级级直到内存中的页表。若不命中，在磁盘中加载物理页到主存中使 PTE 合法，重新启动指令。 此过程中 PPO = VPO 恒成立，一开始就将其取出并在 Cache 中查找 PA，直到返回 CT 进行检查。 安全性可以方便地在 PTE 中增加许可位来实现对内存访问的限制。违反将会触发段错误（segmentation fault）。 优化： 在高速缓存中缓存页表条目； MMU 内置 TLB, TLBT + TLBI &#x3D; VPN（若TLB 有 2^t 个组，TLBI 就为 t 位） 多级页表（只有一级页表才需要在主存中，二级可以根据虚拟内存创建或是持空，只有最常使用的才缓存在主存中）对应 VPN 被分成多块。由于 TLB，访问多级页表的开销可承受。 注意：高速缓存 Cache 访问通常用 物理地址 而不是虚拟地址，因为这样能避免多进程共享同一物理页时带来的冲突，也能避免权限检查在 Cache 前额外处理。使用物理地址更简单、安全、通用。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://happy-door.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"默认标签","slug":"默认标签","permalink":"https://happy-door.github.io/tags/%E9%BB%98%E8%AE%A4%E6%A0%87%E7%AD%BE/"}],"author":"土土"},{"title":"waline暗黑模式字体颜色调整","slug":"waline-darkmode","date":"2025-12-02T03:54:35.000Z","updated":"2025-12-02T03:58:37.657Z","comments":true,"path":"2025/12/02/waline-darkmode/","permalink":"https://happy-door.github.io/2025/12/02/waline-darkmode/","excerpt":"问题：暗黑模式下waline评论与背景颜色接近，难以看清。 本篇记录如何在 Volantis 中覆盖 waline 的暗黑模式评论字体颜色。","text":"问题：暗黑模式下waline评论与背景颜色接近，难以看清。 本篇记录如何在 Volantis 中覆盖 waline 的暗黑模式评论字体颜色。 waline 的评论正文颜色加载自（cdn.yml中设置）官方的 waline.css，其中 1--waline-color: #444; Waline 评论正文使用的是： 123[data-waline] p &#123; color: var(--waline-color);&#125; 解决方案：在 themes\\volantis\\source\\css_style_plugins_dark\\dark_async.styl 中增加： 12345678910111213141516async_dark() ··· if hexo-config(&#x27;comments.service&#x27;)==&#x27;waline&#x27; --waline-color: #c1c1c1ff !important; // 评论正文颜色 ···@media (prefers-color-scheme: dark) :root --color-mode: &#x27;dark&#x27; :root:not([color-scheme]) async_dark() @import &#x27;dark_plugins&#x27;[color-scheme=&#x27;dark&#x27;] async_dark() @import &#x27;dark_plugins&#x27; 这样就覆盖原本的文字颜色设置了。完整源码请查看这里","categories":[{"name":"逍遥门持续装修中","slug":"逍遥门持续装修中","permalink":"https://happy-door.github.io/categories/%E9%80%8D%E9%81%A5%E9%97%A8%E6%8C%81%E7%BB%AD%E8%A3%85%E4%BF%AE%E4%B8%AD/"}],"tags":[],"author":"土土"},{"title":"hexo写文章","slug":"hexo写文章","date":"2025-11-29T12:57:10.000Z","updated":"2025-12-06T08:13:45.797Z","comments":true,"path":"2025/11/29/hexo写文章/","permalink":"https://happy-door.github.io/2025/11/29/hexo%E5%86%99%E6%96%87%E7%AB%A0/","excerpt":"","text":"Hexo 新建文章时会自动复制 scaffolds&#x2F;post.md 的内容作为文章开头。 如果你执行： 1hexo new post &quot;hexo写文章&quot; 它会生成： 1source/_posts/hexo写文章.md 并将 scaffolds&#x2F;post.md 的内容复制进去。 文章开头有一个 Front-Matter（YAML 头部），用于告诉 Hexo 和主题这篇文章的各种元数据。保留并更改你需要的部分。 当你想呈现一个pdf文件的时候，请先确保它放在source/pdf文件夹下，然后执行： 1hexo new pdf &quot;文件名&quot; 其余实现同上。","categories":[{"name":"新弟子进！","slug":"新弟子进！","permalink":"https://happy-door.github.io/categories/%E6%96%B0%E5%BC%9F%E5%AD%90%E8%BF%9B%EF%BC%81/"}],"tags":[],"author":"Benetaid"},{"title":"Git功法入门","slug":"gitguideline","date":"2025-05-20T16:00:00.000Z","updated":"2025-11-28T16:00:00.000Z","comments":true,"path":"2025/05/21/gitguideline/","permalink":"https://happy-door.github.io/2025/05/21/gitguideline/","excerpt":"","text":"前言本篇旨在介绍逍遥门日常生活中常用的几个git操作，帮助不熟悉git的朋友快速上手，顺便给某些总是记不住这些操作的家伙（逃）充当备忘录。 准备工作Git是什么？Git 是一个开源的分布式版本控制系统，用于跟踪文件和目录的更改。Git 通过记录文件的变更历史，允许开发者在不同的时间点查看文件的版本，并且可以轻松地回溯到任何特定的版本。Git 也广泛用于多人合作构建项目（比如我们的happy door!）。 Git 的安装下载 Git访问 Git 官方网站（https://git-scm.com），下载适合 Windows 的安装包。运行安装程序，按照提示进行安装。在安装过程中，可以选择默认的设置，它会自动配置一些常用的 Git 工具，如 Git Bash（一个命令行工具，方便在 Windows 系统中使用 Git 命令，后面会提到）。 Git 的配置全局配置用户名和邮箱打开命令行工具（如 Git Bash、终端等），输入以下命令配置用户名：git config –global user.name “Your Name”把 “Your Name” 替换为你自己的名字。输入以下命令配置邮箱：git config –global user.email “your_email@example.com“把 “your_email@example.com” 替换为你自己的邮箱地址。这些信息会在你提交代码到仓库时被记录，用于标识提交者。 关于 Git BashWindows 系统下，打开文件资源管理器，进入特定的目录，然后右键 → “显示更多选项” → Git Bash。（当然，也可以打开后使用cd 切换到目标目录） Git Bash 和终端和命令提示符相比有什么好处？事实上，Windows系统的很多终端命令和Liunx、Unix系统有所差异，而Git Bash 作为一个基于 MinGW 的环境，它在 Windows 系统上提供了一个类似 Unix 的命令行界面。这意味着你在 Windows 系统上可以使用许多常见的 Unix 命令和工具（如 ls、cp、mv、grep 等），而不需要安装额外的软件。此外，Git Bash 是 Git for Windows 的一部分，它专门为 Git 操作设计，提供了对 Git 命令的优化支持。在 Git Bash 中运行 Git 命令时，你可能会获得更好的性能和更友好的提示信息。好吧，更多的我也编不出来了……不用白不用嘛。 部分快捷键或者你可以鼠标右键解决一切（）。Ctrl + (Fn) + Insert：复制。Shift + (Fn) + Insert：粘贴。 Git 的主要操作下面是在逍遥门经常出现的 Git 使用场景: 修改文件并提交你可以直接在我们的github网站上操作，但通常来说我们更建议你使用git。 创建一个文件夹来存放你的代码，进入这个文件夹，然后初始化仓库： 1git init 这个操作会生成 .git 隐藏文件夹，里面包含了 Git 仓库的所有配置和数据。 添加远程仓库地址： 1git remote add origin https://github.com/your_username/your_repository.git 我们是在GitHub这个代码托管平台上创建的仓库，需要在命令行中输入以上命令将远程仓库地址添加到本地仓库： 这里的 “origin” 是一个默认的远程仓库别名，你可以根据需要使用其他名字，但 “origin” 是最常用的。同时，将 “https://github.com/your_username/your_repository.git” 替换为你自己的远程仓库地址，比如我们的内门就是https://github.com/Happy-Door/InDoor (记得加“.git”!)。 拉取更改： 1git pull origin &lt;branch-name&gt; 从远程仓库拉取更改并合并到当前分支，也是获取仓库最新代码的途径。这样以后你就可以在本地修改你想修改的文件了！相当于git fetch origin（获取远程仓库的最新内容） 加上 git merge origin&#x2F;main（将远程分支的更改合并到当前本地分支）。如果存在冲突，Git 会提示你解决这些冲突。 查看状态： 1git status 查看当前仓库的状态，包括未提交的更改。一般在进行push操作前，我们都建议进行这个操作，确保所有的改变都已提交，防止代码发生冲突。 添加文件： 1git add &lt;file&gt; 在git status告诉你有变化的文件后，你就可以执行这个操作将文件添加到暂存区，准备提交。（**注意！**这里的文件名必须包含完整的相对路径，比如/path/to/file.txt，具体的已经在git bash的提示信息中给出来了~） 另外，如果是Windows用户，你很可能会看到 1warning: in the working copy of &#x27;source/_posts/gitguideline.md&#x27;, CRLF will be replaced by LF the next time Git touches it 这是因为Git默认使用CRLF（回车符+换行符）作为行结束符，而Windows系统默认使用LF作为行结束符。总之，你可以选择通过以下命令设置全局配置或仓库特定配置，这样以后Git不会自动转换换行符，文件中的换行符将保持原样。全局配置： 1git config --global core.autocrlf false 仓库特定配置(移动到仓库所在的目录)： 1git config core.autocrlf false 提交更改： 1git commit -m &quot;Commit message&quot; 接下来，将暂存区的更改提交到本地仓库，并添加提交信息。 推送更改： 1git push origin &lt;branch-name&gt; 当你git status没有问题后，将本地分支的更改推送到远程仓库。 在第一次创建之后，你就只需要使用4、5、6、7完成一次提交了。 其他常见操作 查看提交历史： 1git log 查看提交历史记录。 创建分支： 1git branch &lt;branch-name&gt; 创建一个新的分支。 切换分支： 1git checkout &lt;branch-name&gt; 切换到指定的分支。 合并分支： 1git merge &lt;branch-name&gt; 将指定分支的更改合并到当前分支。 克隆仓库： 1git clone &lt;repository-url&gt; 从远程仓库克隆一个副本到本地。效果相当于git remote add origin 加上 git fetch origin。 结束之前由于我们的逍遥门采用了hexo主题，所以直接提交是不能在主页上看到变化的。想要即刻看到变化，请进行以下操作！ 生成静态文件 1hexo generate 部署到远程仓库 1hexo deploy 如果出现了意外情况，比如新的内容还是没有加载出来，可以等一会儿或者使用命令hexo clean，再进行上面的两个操作。如果想在本地查看生成的网页效果，使用命令 1hexo server 结束！感谢各位的捧场，今天的早课结束啦ᕕ ( ᐛ ) ᕗ","categories":[{"name":"新弟子进！","slug":"新弟子进！","permalink":"https://happy-door.github.io/categories/%E6%96%B0%E5%BC%9F%E5%AD%90%E8%BF%9B%EF%BC%81/"}],"tags":[]},{"title":"在GitHub上架设博客网站","slug":"website-build","date":"2025-04-07T16:00:00.000Z","updated":"2025-11-29T13:12:31.359Z","comments":true,"path":"2025/04/08/website-build/","permalink":"https://happy-door.github.io/2025/04/08/website-build/","excerpt":"","text":"简单介绍Github提供了Github Pages来帮助我们架设静态网站，Github Pages是一项免费的静态文件部署服务, 通过它可以把生成的静态网站托管在Github上。本篇博客不负责介绍其他搭建网站方式和各自的优劣，我们直接开始吧。 Step 1：注册一个github账号访问Github并点击 sign up 进行注册，需要提供用户名、密码和邮箱，不需要手机号。用户名不允许重复，顺带一提，在Github上搭建的个人网站，用户名最终会出现在网址上，所以记得取个自己喜欢的名字！ 接着Github会询问你是否需要付费使用。免费服务足够满足大部分开发者的需求了，付费服务主要面向团队和企业。 此后Github会问你使用Github的目的、熟练度等等，类似于用户调研，照实填写即可。 之后Github会向你注册时填写的邮箱发送验证信息，在邮件中打开链接进行确认，账号就顺利激活了。 Step 2：创建一个仓库点击 sign in 登录你的Github账号，在个人（或组织）的首页找到头像下“Your repositories”的选项，点击new新建一个仓库。 步骤包括：命名，描述（选填），选择公开与否（默认是public，公开的仓库所有人都可以访问，private则只有个人可访问，对组织而言则是部分人可访问，同样也影响最后生成的网站访问权限。不过这个选项是随时可以修改的），选择是否生成一个README（介绍文件），点击“create repository”创建。 接下来会有一大堆关于git操作的指示，新手可以先跳过，直接点击create a new file构建一个新文件 index.html，（静态http文件托管服务的默认访问文件就是index.html）用途是渲染网页。 随后点击导航栏中的设置Settings，找到侧边栏中的Pages,source选择 deploy from a branch, branch里的分支改成你的主分支（main, master, gh-pages等等），目录默认是根目录。生成站点页面时Github Pages会在你选择的分支里找到相关文件。这个时候刷新页面就可以看到Github生成的网址了。 Step 3：配置主题参见Jekyll主题配置；Hexo主题配置。 Step 4：写博文– 未完待续 –","categories":[{"name":"github","slug":"github","permalink":"https://happy-door.github.io/categories/github/"}],"tags":[]}],"categories":[{"name":"新弟子进！","slug":"新弟子进！","permalink":"https://happy-door.github.io/categories/%E6%96%B0%E5%BC%9F%E5%AD%90%E8%BF%9B%EF%BC%81/"},{"name":"笔记","slug":"笔记","permalink":"https://happy-door.github.io/categories/%E7%AC%94%E8%AE%B0/"},{"name":"逍遥门持续装修中","slug":"逍遥门持续装修中","permalink":"https://happy-door.github.io/categories/%E9%80%8D%E9%81%A5%E9%97%A8%E6%8C%81%E7%BB%AD%E8%A3%85%E4%BF%AE%E4%B8%AD/"},{"name":"github","slug":"github","permalink":"https://happy-door.github.io/categories/github/"}],"tags":[{"name":"默认标签","slug":"默认标签","permalink":"https://happy-door.github.io/tags/%E9%BB%98%E8%AE%A4%E6%A0%87%E7%AD%BE/"}]}